# GRAPHRAG_WBS

## [수정된 전체 프로세스 WBS: ESG GraphRAG Pipeline]


# neo4j_graphrag/retrievers /text2cypher 관련 프롬프트 링크
# https://github.com/neo4j/neo4j-graphrag-python/blob/main/src/neo4j_graphrag/retrievers/text2cypher.py

### **Phase 1. Knowledge Graph 구축 (Data Engineering)**

### **Step 1. 데이터 준비 (Input Layer)**

- **작업 내용:** 원본 데이터(CSV/PDF) 로드 및 텍스트 청킹(Chunking).
- **핵심 도구:** `pandas`, `PyPDF2`, `LangChain TextSplitters`.

### **Step 2. 정보 추출 및 정규화 (Extraction & Refinement Layer)**

- **작업 내용:** LLM을 이용한 스키마 기반 추출 및 데이터 클리닝.

## 1. 데이터 누락 및 비용 최적화 (가장 큰 문제)

현재 코드는 CSV의 **한 줄(row)마다 LLM API를 호출**합니다. 1,000개의 행이면 1,000번 호출하게 되는데, 이는 다음과 같은 문제를 야기합니다.

- **비용 효율 저하:** 각 호출마다 System Prompt가 중복 전달되어 토큰 낭비가 심합니다.
- **속도:** `gpt-4o-mini`가 빠르더라도 1,000번의 HTTP 요청은 네트워크 오버헤드 때문에 매우 오래 걸립니다.
- **개선안:** 5~10개의 행을 하나의 프롬프트로 묶어서 처리(Batching)하거나, Pandas의 `to_json` 등으로 데이터를 압축해서 전달하세요.

## 2. ID 정규화 및 엔티티 해상도(Entity Resolution) 문제

`normalize_id` 함수에서 `label`과 `name`을 조합해 ID를 만드는데, 실무 데이터에서는 다음과 같은 상황이 발생합니다.

- **동의어 문제:** "MSCI"와 "MSCI Inc"는 같은 노드여야 하지만, 현재 로직으로는 `Company_msci`와 `Company_msci_inc`라는 **서로 다른 노드**로 생성됩니다.
- **해결책:** LLM에게 "이미 추출된 노드 리스트를 참고해서 일치시켜라"라고 시키는 것은 토큰 초과로 불가능합니다. 추출 후에 **Fuzzy Matching** 라이브러리를 쓰거나, LLM 프롬프트에 "회사 이름은 약어 대신 공식 명칭을 사용하라"는 지침을 더 강력하게 넣어야 합니다.

전처리

- **핵심 세부 작업:**
    - **Schema 추출:** Pydantic 모델을 통한 노드/관계 추출 (GPT-4o-mini).
    - **ID 정규화 (`normalize_id`):** 엔티티 식별자 통일 (예: `Company_NetApp`).
    - **관계 통일 (`rel_type_map`):** 유사 관계 타입 병합 (예: `GENERATES` → `HAS_REPORT`).
    - **중복 제거 (De-duplication):** 중복된 노드 및 관계 데이터 병합.

### **Step 3. 데이터 통합 및 적재 (Storage Layer)**

- **작업 내용:** 정제된 JSON 데이터를 Neo4j DB에 반영.
- **핵심 도구:** `neo4j` Python Driver, **Cypher Query**.
- **결과물:** Neo4j Browser 내 지식 그래프 시각화.

---

### **Phase 2. GraphRAG 지능화 (Intelligence Layer) - *추가 필요***

### **Step 4. 벡터 인덱싱 및 그래프 임베딩**

- **작업 내용:** 자연어 검색을 위해 노드 및 텍스트 속성을 벡터화하여 인덱스 생성.
- **핵심 도구:** `Neo4j Vector Index`, `OpenAI Embeddings`.
- **이유:** 사용자의 질문(자연어)과 가장 유사한 노드를 찾기 위해 필수적입니다.
- **Step 4-1. 데이터 적재 (Loading):** 정제된 JSON을 Cypher 쿼리로 Neo4j에 밀어넣기 (현재 준비된 단계).
- **Step 4-2. 벡터 인덱스 생성 (Indexing):** Neo4j에 저장된 노드들 중 검색에 사용할 텍스트를 골라 벡터 인덱스를 설정.
- **Step 4-3. 임베딩 업데이트 (Embedding):** 각 노드에 실제 수치화된 벡터값을 채워넣기.

### **Step 5. 커뮤니티 요약 (Optional but Recommended)**

- **작업 내용:** 대규모 그래프를 그룹화하여 상위 수준의 요약 정보를 생성.
- **핵심 도구:** `Neo4j Graph Data Science (GDS)`.
- **이유:** 전체적인 ESG 경향성을 묻는 질문에 답하기 위함입니다.

---

### **Phase 3. 서비스 구현 (Agent Layer) - *추가 필요***

### **Step 6. GraphRAG Agent 설계**

- **작업 내용:** 사용자의 질문에 따라 Cypher 쿼리를 생성하거나 벡터 검색을 수행하는 에이전트 구축.
- **핵심 도구:** `LangChain`, `neo4j-graphrag`, **Cypher QA Chain**.
- **프로세스:**
    1. **Question 분석:** 사용자의 질문 수신.
    2. **Cypher 생성:** 질문을 Cypher 쿼리로 변환 (LLM).
    3. **검색:** DB에서 관련 데이터 및 그래프 구조 추출.
    4. **답변 생성:** 추출된 문맥(Context)을 바탕으로 최종 답변 생성.

| **소단계** | **작업 명칭** | **상세 활동 (Tasks)** |
| --- | --- | --- |
| **7.1** | **등급 데이터 추출 검증** | `Climate Change`, `General` 등 카테고리별 등급 매칭 정확도 확인 |
| **7.2** | **등급 위계 로직 적용** | A > BB 와 같은 등급 간 우열 관계를 LLM이 올바르게 해석하는지 테스트 |
| **7.3** | **멀티 행(Row) 요약 분석** | 여러 행에 걸친 등급 정보를 종합하여 기업의 전반적인 ESG 수준 요약 |
| **7.4** | **정성적 텍스트 연결성 테스트** | 좌측의 영문 텍스트(요약)와 우측의 등급이 논리적으로 일치하게 답변하는지 확인 |

🔄 GraphRAG의 작동 데이터 흐름 (Data Flow)

- **사용자 질문 (자연어):** * "환경 등급이 A인 회사가 어디야?"라고 일상 언어로 질문합니다.
- **Cypher 번역 (LLM의 역할):** * `st.py`에 작성된 **`custom_prompt`*를 가이드 삼아, GPT-4o-mini가 이 질문을 Neo4j가 알아듣는 **Cypher 쿼리**로 변환합니다.
    - *예: `MATCH (c:Company)-[:HAS_REPORT]->... WHERE rat.name = 'E Rating A' RETURN c.name`*
- **그래프 탐색 (Neo4j의 역할):** * 번역된 쿼리가 Neo4j DB로 날아가서 수천 개의 노드와 관계 중 조건에 맞는 데이터를 **정확하게** 집어냅니다.
- **최종 답변 생성 (LLM의 역할):** * DB에서 뽑아온 딱딱한 데이터(결과값)를 다시 GPT에게 줍니다. GPT는 이를 읽기 좋은 한국어 문장으로 다듬어서 사용자에게 보여줍니다.

### 리트리버는 구체적으로 무슨 일을 하나요?

리트리버가 없으면 AI는 자기가 학습한 기억(지식)에만 의존해서 대답합니다. 하지만 리트리버가 있으면 **"잠시만요, 제가 정확한 데이터베이스를 확인하고 올게요"**라고 하며 최신 데이터를 찾아냅니다.

1. **질문 이해:** 사용자가 "NetApp의 ESG 등급 뭐야?"라고 묻습니다.
2. **검색 전략 수립:** 질문을 분석하여 어떤 방식으로 데이터를 찾을지 결정합니다.
3. **데이터 추출:** 데이터베이스에서 가장 관련성이 높은 정보(노드, 관계 등)를 뽑아냅니다.
4. **전달:** 뽑아온 정보를 LLM(GPT)에게 전달하여 답변을 만들게 합니다.

| **종류** | **작동 방식** | **특징** |
| --- | --- | --- |
| **Text2Cypher Retriever** (현재 사용 중) | 질문을 **Cypher 쿼리**로 번역해서 DB를 조회 | **정확한 수치, 관계**를 찾을 때 가장 강력함 (예: "A등급인 회사는?") |
| **Vector Retriever** | 질문을 **숫자(벡터)**로 바꿔서 비슷한 의미를 조회 | **문맥, 비슷한 내용**을 찾을 때 좋음 (예: "기후 변화와 관련된 내용") |
| **Hybrid Retriever** | 위 두 가지 방식을 섞어서 사용 | 가장 똑똑하지만 구현이 복잡함 |

- Vector vs Cypher

| **비교 항목** | **벡터 유사도 (Vector)** | **Cypher 쿼리 (Graph)** |
| --- | --- | --- |
| **검색 방식** | 의미적 유사성 (비슷한 거 찾기) | 구조적 경로 (연결된 거 찾기) |
| **주요 용도** | 비정형 텍스트 요약, 주제 탐색 | 수치 비교, 다단계 관계 추적 |
| **장점** | 질문이 모호해도 답을 함 | 결과가 정확하고 논리적임 |
| **단점** | 가끔 '환각(거짓말)'을 함 | 쿼리가 틀리면 답변을 못 함 |
| **비유** | "기후 관련 내용 다 가져와" | "A사의 B보고서 속 C등급 가져와" |

![image.png](image.png)

### neo4j에서 특정 회사의 관계가 적은 이유

LLM(`gpt-4o-mini`)은 프롬프트에서 "connected graph"로 만들라고 하면, 똑똑하게도 **중복된 정보는 생략하고 가장 효율적인 그래프**를 그리려고 합니다.

- 이미 위에서 `ACI Worldwide`의 등급을 언급했다면, 다음 행을 처리할 때는 "이건 이미 앞에서 말한 거니까 굳이 또 객체화해서 내보낼 필요 없겠지?"라고 판단하여 노드나 관계 리스트에서 빠뜨릴 수 있습니다.

### 3. 지금 상태로 계속 가도 될까요? (중요)

사실 지금의 **"압축된 그래프"**가 오류는 아닙니다. 오히려 **GraphRAG의 정석**에 가깝습니다.

- **장점:** 데이터가 깔끔하게 정리되어 있어, 나중에 챗봇이 질문을 받았을 때 "ACI Worldwide의 등급은 A입니다"라고 중복 없이 명확하게 대답할 수 있습니다.
- **단점:** 시각화했을 때 `ACI Worldwide` 주변이 썰렁해 보입니다.

**결론:** 시각적인 풍성함보다 **"챗봇의 정확한 답변"**이 목적이라면 지금 코드를 그대로 유지하고 1,000개 추출을 끝내시는 것을 추천합니다. 하지만 **"행마다의 디테일(예: Social에서의 A와 Environment에서의 A는 다르다)"**을 살리고 싶다면 위 수정안을 적용해야 합니다.
